var __extends=this&&this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);a.prototype=null===b?Object.create(b):(c.prototype=b.prototype,new c)};define(["require","exports"],function(a,b){"use strict";var c="attribute vec3 aVertexPosition;\nvarying vec2 vTextureFieldCoords;\nvarying vec2 vTextureNoiseCoords;\nuniform mat4 model;\n\nvoid main(void) {\n    gl_Position = model * vec4(aVertexPosition, 1.0);\n    vTextureFieldCoords = aVertexPosition.xy * 0.5 + 0.5;\n    vTextureNoiseCoords = aVertexPosition.xy * 0.5 + 0.5;\n}\n",d="#define N 15\n#define L 15.0\nprecision highp float;\nvarying vec2 vTextureFieldCoords;\nvarying vec2 vTextureNoiseCoords;\nuniform sampler2D image;\nuniform sampler2D field;\nuniform float size;\nuniform float maxv;\nvarying vec2 v_texCoord;\nvec2 pointi;\nvec2 noise_choord;\nvec2 pointf;\nvec2 vector;\nvec2 v;\nfloat len;\nconst float eps = 0.000001;\n\nfloat top_distance()\n{\n    if (abs(vector.y) < eps) {\n        return 2.0;\n    }\n    return (pointi.y + 1.0 - pointf.y) / vector.y;\n}\nfloat bottom_distance()\n{\n    if (abs(vector.y) < eps) {\n        return 2.0;\n    }\n    return (pointi.y - pointf.y) / vector.y;\n}\nfloat left_distance()\n{\n    if (abs(vector.x) < eps) {\n        return 2.0;\n    }\n    return (pointi.x - pointf.x) / vector.x;\n}\nfloat right_distance()\n{\n    if (abs(vector.y) < eps) {\n        return 2.0;\n    }\n    return (pointi.x + 1.0 - pointf.x) / vector.x;\n}\nfloat get_distance()\n{\n    float top    = max(top_distance()   , 0.0);\n    float bottom = max(bottom_distance(), 0.0);\n    float left   = max(left_distance()  , 0.0);\n    float right  = max(right_distance() , 0.0);\n\n    float minimum = 2.0;\n    if (top    > eps) minimum = min(top   , minimum);\n    if (bottom > eps) minimum = min(bottom, minimum);\n    if (left   > eps) minimum = min(left  , minimum);\n    if (right  > eps) minimum = min(right , minimum);\n\n    if (minimum  < eps   ) return 0.0;\n    if (minimum == 2.0   ) return 0.0;\n    pointf += vector * minimum;\n    if (minimum == top   ) pointi.y += 1.0, noise_choord.y += 1.0;\n    if (minimum == bottom) pointi.y -= 1.0, noise_choord.y -= 1.0;\n    if (minimum == left  ) pointi.x -= 1.0, noise_choord.x -= 1.0;\n    if (minimum == right ) pointi.x += 1.0, noise_choord.x += 1.0;\n    return minimum;\n}\nvec2 get_vector(vec2 p)\n{\n    vec4 vt = texture2D(field, p / size);\n    len = vt.z;\n    return normalize(vt.xy);\n}\nfloat core(float arg)\n{\n    return exp(-pow(arg, 2.0) / (2.0 * L) ) / sqrt(2.0 * L * 3.1415926535);\n}\nfloat integrate(float start, float stop)\n{\n    float precize = 5.0;\n    float step    = (stop - start) / precize;\n    float result  = 0.0;\n    float k       = 0.0;\n    for(float i = 0.0; i < 5.0; i += 1.0) {\n        result += core(start + step * i);\n    }\n    return result;\n}\nvoid main()\n{\n    float dist = 0.0, norm = 0.0;\n    vec4 result = vec4(0.0);\n    pointi = floor(vTextureFieldCoords * size);\n    noise_choord = floor(vTextureNoiseCoords * size);\n    pointf = pointi + vec2(0.5, 0.5);\n    vector = get_vector(pointi);\n    //positive stream line\n    for(int i = 0; i < N; i++) {\n        vec4 tmp  = texture2D(image, noise_choord / size);\n        float mod = get_distance();\n        if (mod < eps) break;\n        float t   = integrate(dist, dist + mod);\n        dist     += mod;\n        norm     += t;\n        result   += tmp * t;\n        vector    = get_vector(pointi);\n    }\n    //negative stream line\n    dist   = 0.0;\n    pointi = floor(vTextureFieldCoords * size);\n    noise_choord = floor(vTextureNoiseCoords * size);\n    pointf = pointi + vec2(0.5, 0.5);\n    vector = -get_vector(pointi);\n    for(int i = 0; i < N; i++) {\n        vec4 tmp  = texture2D(image, noise_choord / size);\n        float mod = get_distance();\n        if (mod < eps) break;\n        float t   = integrate(-dist, -dist - mod);\n        dist     += mod;\n        norm     += t;\n        result   += tmp * t;\n        vector    = -get_vector(pointi);\n    }\n\n    result /= norm;\n    vec4 clr = mix(vec4(0.0, 0.0, 1.0, 1.0), vec4(1.0, 0.5, 0.0, 1.0), len / maxv);\n    gl_FragColor = result * clr;\n}",e=function(){function a(a){this.gl=a,this.program=a.createProgram()}return a.prototype.attach=function(a){this.gl.attachShader(this.program,a.shaderID)},a.prototype.detach=function(a){this.gl.detachShader(this.program,a.shaderID)},a.prototype.link=function(){var a=this.gl;a.linkProgram(this.program),a.getProgramParameter(this.program,a.LINK_STATUS)||(console.log("Program link error: "+a.getProgramInfoLog(this.program)),a.deleteProgram(this.program))},a.prototype.use=function(){this.gl.useProgram(this.program)},a.prototype.getUniLoc=function(a){return this.gl.getUniformLocation(this.program,a)},a.prototype.getAttribLoc=function(a){return this.gl.getAttribLocation(this.program,a)},a}();b.ShaderProgram=e;var f=function(){function a(a,b,c){this.gl=a,this.type=b,this.source=c,this.loadShader()}return a.prototype.loadShader=function(){var a=this.gl;this.shaderID=a.createShader(this.type),a.shaderSource(this.shaderID,this.source),a.compileShader(this.shaderID),a.getShaderParameter(this.shaderID,a.COMPILE_STATUS)||(console.log("Shader compilation error: "+a.getShaderInfoLog(this.shaderID)),a.deleteShader(this.shaderID))},a}();b.Shader=f;var g=function(a){function b(b){a.call(this,b),this.vertexShader=new f(b,b.VERTEX_SHADER,c),this.fragmentShader=new f(b,b.FRAGMENT_SHADER,d),this.attach(this.vertexShader),this.attach(this.fragmentShader),this.link(),this.use(),this.size_loc=this.getUniLoc("size"),this.model_loc=this.getUniLoc("model"),this.max_loc=this.getUniLoc("maxv"),this.size=512,b.uniform1i(this.getUniLoc("image"),0),b.uniform1i(this.getUniLoc("field"),1)}return __extends(b,a),Object.defineProperty(b.prototype,"size",{get:function(){return this.gl.getUniform(this.program,this.size_loc)},set:function(a){this.gl.uniform1f(this.size_loc,a)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"max",{get:function(){return this.gl.getUniform(this.program,this.max_loc)},set:function(a){this.gl.uniform1f(this.max_loc,a)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"model",{get:function(){return this.gl.getUniform(this.program,this.model_loc)},set:function(a){this.gl.uniformMatrix4fv(this.model_loc,!1,a)},enumerable:!0,configurable:!0}),b}(e);b.licShaderProgram=g;var h=function(){function a(a,b){this.gl=a,this.shader=b}return a}();b.Drawable=h;var i=function(a){function b(b,c){a.call(this,b,c),this.vertices=[-1,-1,0,-1,1,0,1,1,0,1,-1,0],this.indeces=[0,1,2,2,3,0],this.attribName="aVertexPosition",this.vertexBuffer=b.createBuffer(),this.indexBuffer=b.createBuffer(),this.numElements=this.indeces.length,b.bindBuffer(b.ARRAY_BUFFER,this.vertexBuffer),b.bufferData(b.ARRAY_BUFFER,new Float32Array(this.vertices),b.STATIC_DRAW),b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,this.indexBuffer),b.bufferData(b.ELEMENT_ARRAY_BUFFER,new Uint16Array(this.indeces),b.STATIC_DRAW),b.enableVertexAttribArray(c.getAttribLoc(this.attribName))}return __extends(b,a),Object.defineProperty(b.prototype,"FieldTexture",{get:function(){return this.fieldTexture},set:function(a){this.fieldTexture=a},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"NoiseTexture",{get:function(){return this.noiseTexture},set:function(a){this.noiseTexture=a},enumerable:!0,configurable:!0}),b.prototype.Draw=function(){var a=this.gl,b=this.shader.getAttribLoc(this.attribName);this.FieldTexture.Bind(),this.NoiseTexture.Bind(),a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer),a.vertexAttribPointer(b,3,a.FLOAT,!1,0,0),a.drawElements(a.TRIANGLES,this.numElements,a.UNSIGNED_SHORT,0)},b}(h);b.Square=i;var j=function(){function a(a,b,c){void 0===b&&(b=WebGLRenderingContext.TEXTURE0),void 0===c&&(c=WebGLRenderingContext.TEXTURE_2D),this.gl=a,this.active=b,this.target=c,this.texture=this.gl.createTexture()}return a.prototype.Bind=function(){this.gl.activeTexture(this.active),this.gl.bindTexture(this.target,this.texture)},a.createNoiseTexture=function(b,c){var d=new a(b);return d.Bind(),b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL,1),b.texImage2D(b.TEXTURE_2D,0,b.RGBA,b.RGBA,b.UNSIGNED_BYTE,c),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.LINEAR),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.LINEAR),b.generateMipmap(b.TEXTURE_2D),d},a.fromArray=function(b,c,d,e){var f=new a(b,b.TEXTURE1);return f.Bind(),b.texImage2D(b.TEXTURE_2D,0,b.RGBA,d,e,0,b.RGBA,b.FLOAT,c),b.texParameterf(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE),b.texParameterf(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE),b.texParameterf(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.LINEAR),b.generateMipmap(b.TEXTURE_2D),f},a.createFieldTexture=function(b,c){for(var d=c.length*c[0].length,e=c[0].length,f=c.length,g=4*d,h=new Float32Array(g),i=0,j=0;j<f;j++)for(var k=0;k<e;k++){var l=4*(j*e+k),m=c[j][k][0],n=c[j][k][1],o=Math.sqrt(Math.pow(m,2)+Math.pow(n,2));i=Math.max(i,o),h[l+0]=m/o,h[l+1]=n/o,h[l+2]=o,h[l+3]=i}var p=new a(b,b.TEXTURE1);return p.Bind(),b.texImage2D(b.TEXTURE_2D,0,b.RGBA,e,f,0,b.RGBA,b.FLOAT,h),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST),p},a}();b.Texture=j;var k=function(){function a(){}return a}();b.Camera=k});